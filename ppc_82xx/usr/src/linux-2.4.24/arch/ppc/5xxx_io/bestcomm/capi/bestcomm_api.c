/******************************************************************************
*
* Copyright (C) 2003  Motorola, Inc.
* 
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
* 
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
* 
*
* Filename:     $Source$
* Author:       $Author$
* Locker:       $Locker$
* State:        $State$
* Revision:     $Revision$
*
* Functions:    
*
* History:      Use the RCS command rlog to display revision history
*               information.
*
* Description:  
*
* Notes:                
*******************************************************************************/

/*!
 * \mainpage	Introduction
 *
 * \author	Motorola Semiconductor Products Sector
 * \date	29 May 2003
 */

/*!
 * \file	bestcomm_api.c
 *
 * Bestcomm_api.c implements most of the BestComm C API. The TaskSetup()
 * function is generated by the BestComm Task API tools in
 * code_dma/dma_image.capi.c.
 */

#include "ppctypes.h"
#include "bestcomm_api.h"
#include "task_api/bestcomm_cntrl.h"
#include "task_api/bestcomm_api_mem.h"
#include "task_api/tasksetup_bdtable.h"

/*
 * Hidden API data per task.
 */
 
static BDIdx	BDHead[MAX_TASKS];
static BDIdx	BDTail[MAX_TASKS];
uint8   *MBarGlobal;
sint64	MBarPhysOffsetGlobal;
uint8 *TaskTableFree;
uint32 SramOffsetGlobal = 0;

/*!
 * \brief	Initialize the API.
 * \param	MBarRef		Reference pointer to the device register memory
 *						map.
 *
 * \returns	TASK_ERR_NO_ERR on successful initialization.
 *			or TASK_ERR_API_ALREADY_INITIALIZED.
 *
 * This function is only used with physical addresses. 
 *
 * This function will also initialize API internal variables. The return
 * value TASK_ERR_API_ALREADY_INITIALIZED is intended to help determine if
 * another process has already instantiated a version of the API. This
 * feature is for new versions of the API and has not been implemented
 * yet.
 */
 int TasksInitAPI(uint8 *MBarRef)
 {
 
 	/*
 	 * Copy pointer of register space to global variable.
 	 * for use by other functions.
 	 */
 	 
 	MBarGlobal = MBarRef;
 	
 	/*
 	 * The offset is 0 if physical and virtual are the same.
 	 */
 	 
 	MBarPhysOffsetGlobal = 0;
 	
 	/*
 	 * IF API has not been initialized yet then...
 	 * Make sure all BestComm interrupts are disabled and not pending.
 	 * Make sure all tasks are disabled.
 	 * This feature can only be put in after a way has been found to communicaticate
 	 * with other processes.
 	 */
 	 
 	return TASK_ERR_NO_ERR;
 }
 
 /*!
 * \brief	Initialize the API when virtual memory is used.
 * \param	MBarRef		Reference pointer to the device register memory
 *						map.
 * \param	MBarPhys	Actual physical location of MBAR device register memory map.
 *
 * \returns	TASK_ERR_NO_ERR on successful initialization.
 *			or TASK_ERR_API_ALREADY_INITIALIZED.
 *
 * This function allows using virtual memory addresses as well as physical
 * addresses. All device registers are offset to the address supplied here,
 * so the virtual memory space should include enough space for the entire
 * register set of the device to include the SRAM space.
 *
 * This function will also initialize API internal variables. The return
 * value TASK_ERR_API_ALREADY_INITIALIZED is intended to help determine if
 * another process has already instantiated a version of the API. This
 * feature is for new versions of the API and has not been implemented
 * yet.
 */
 int TasksInitAPI_VM(uint8 *MBarRef, uint8 *MBarPhys)
 {
 
 	/*
 	 * Copy pointer of register space to global variable.
 	 * for use by other functions.
 	 */
 	 
 	MBarGlobal = MBarRef;
 	MBarPhysOffsetGlobal =  MBarPhys - MBarRef; 	
 	
 	/*
 	 * IF API has not been initialized yet then...
 	 * Make sure all BestComm interrupts are disabled and not pending.
 	 * Make sure all tasks are disabled.
 	 * This feature can only be put in after a way has been found to communicaticate
 	 * with other processes.
 	 */
 	 
 	return TASK_ERR_NO_ERR;
 }
 
 /*!
  * \brief	This function returns the value of the internal variable
  *			used to keep track of used space in SRAM.
  *
  * \returns The number of bytes from the beginning of SRAM to the end
  *          used space in the SRAM.
  *
  *  This function will return the offset to free space in the SRAM
  *  not used by the CAPI. /b NOTE: /b The returned value is based
  *  on what is in TasksSetSramOffset. This function can
  * not determine what SRAM space was used by another process. There must
  * be some way external to the CAPI to keep track of SRAM space. This
  * function only returns the internal variable used to keep track of buffer
  * descriptors.
  *
  *
  */
  
 uint32 TasksGetSramOffset(void)
 {
 	return SramOffsetGlobal;
 }
 
  /*!
  * \brief	This function stores the number of bytes from the
  *         beginning of SRAM to the end of the used space.
  *
  * \param sram_offset Number of bytes until the beginning of 
  *						free space in the SRAM.
  *
  * \returns Nothing
  *
  * This function sets the free space offset in SRAM.
  * This function must be called before setup in multi-task
  * environments. It is the applications job to determine where the free space in
  * SRAM is. This sets the base offset for the buffer descriptor
  * variables during setup, so to deallocate buffers that have
  * already been set this function should be called with a new
  * offset.
  *
  *
  */
 void TasksSetSramOffset(uint32 sram_offset)
 {
 	/*
 	 * Set the SramOffsetGlobal variable to be used by TaskSetup_BDTable
 	 */
 	
 	SramOffsetGlobal = sram_offset;
 }
 
 /*!
  * \brief	This function is called if the task image was already loaded by another process.
  * \param	sdma Base address of the BestComm register set
  *
  * \returns TASK_ERR_NO_ERR on successful initialization.
  *
  * This function will create the internal pointer tables do deal with the tasks.
  *
  *
  */
int TasksAttachImage(sdma_regs *sdma)
  {
  
  /*
   * Call init_dma_image() to fill in the dma image structure.
   */
   
  	init_dma_image((uint8 *)(sdma->taskBar), MBarPhysOffsetGlobal);
  	
  	return TASK_ERR_NO_ERR;
  }
  
/*!
 * \brief	Initialize a single task.
 * \param	TaskName	Type of task to initialize. E.g. PCI transmit,
 *						ethernet receive, general purpose dual-pointer.
 * \param	TaskParams	Task-specific parameters. The user must fill out
 *						the pertinent parts of a TaskSetupParamSet_t
 *						data structure.
 *
 * Most drivers require both a transmit and receive task. This function
 * returns a task identification token which is a required parameter
 * for most other API functions.
 *
 * Certain values of the structure pointed to by TaskParams are set
 * as a side-effect based on task type. These may be examined after
 * a successful call to TaskSetup(). User-specified values may be
 * overridden.
 */
TaskId TaskSetup( TaskName_t TaskName, TaskSetupParamSet_t *TaskParams );

/*!
 * \brief	Start an initialized task running.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \param	autoStartEnable Boolean for whether autostart bit is enabled.
 *							If this is set then the parameter autoStartTask
 *							defines the task to auto start.
 * \param	autoStartTask	TaskId for task to autostart. If autoStartEnable
 *							is not set then this parameter is a don't care.
 * \param	intrEnable		Boolean for interrupt enable for this task.
 * \returns	TASK_ERR_NO_ERR on success or TASK_ERR_INVALID_ARG if taskId
 *			is invalid.
 */
int TaskStart( TaskId taskId, uint32 autoStartEnable, TaskId autoStartTask,
						uint32 intrEnable  )
{
	if( (0 <= taskId) && (taskId < MAX_TASKS) ) {
		if ( intrEnable ) {
			SDMA_INT_ENABLE( SDMA_INT_MASK, taskId );
		}
		else {
			SDMA_INT_DISABLE( SDMA_INT_MASK, taskId );
		}
		SDMA_TASK_AUTO_START(SDMA_TCR, taskId, autoStartEnable, autoStartTask)
		SDMA_TASK_ENABLE( SDMA_TCR, taskId );
		return TASK_ERR_NO_ERR;
	} else {
		return TASK_ERR_INVALID_ARG;
	}
}

/*!
 * \brief	Stop a running task.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \returns	TASK_ERR_NO_ERR on success or TASK_ERR_INVALID_ARG if taskId
 *			is invalid.
 *
 * Stopping a task is a catastrophic operation. It does not merely
 * pause execution. Context is not saved. Any buffer descriptors are
 * cleared. This should be called, e.g., when a device driver is stopped.
 */
int TaskStop( TaskId taskId )
{
	if( (taskId < 0) || (taskId >= MAX_TASKS) ) {
		return TASK_ERR_INVALID_ARG;
	}

	SDMA_INT_DISABLE( SDMA_INT_MASK, taskId );
	SDMA_TASK_DISABLE( SDMA_TCR, taskId );

	BDHead[taskId] = BDTail[taskId] = 0;
	
	(TaskBDIdxTable[taskId].currBDInUse) = 0;
	
	return TASK_ERR_NO_ERR;
}

/*!
 * \brief	Get the enable/disable status of a task.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \returns	Boolean true indicates enabled or false indicates disabled
 *			or invalid taskId.
 */
int TaskStatus( TaskId taskId )
{
	if( (0 <= taskId) && (taskId < MAX_TASKS) ) {
		return SDMA_TASK_STATUS( SDMA_TCR, taskId ) & 0x8000;
	} else {
		/*
		 * Return false for illegal task IDs.
		 */
		return 0;
	}
}

/*!
 * \brief	Assign a buffer to a buffer descriptor.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \param	buffer0	A buffer to send data from or receive data into a device
 * \param	buffer1 A buffer to send data from or receive data into a device
 * \param	size	Size of the buffer in bytes.
 * \param	bdFlags	Buffer descriptor flags to set. Used by ethernet BD tasks.
 * \returns Handle to the buffer descriptor used by this DMA transfer.
 *			Non-buffer descriptor tasks will return TASK_ERR_NO_ERR.
 *			Error is indicated by a negative return value.
 *
 * This function is used for both transmit and receive buffer descriptor
 * tasks. The buffer may be freed by the TaskBDRelease() function.
 * In the case of tasks with a buffer descriptor with two buffer pointers
 * this function uses both buffer0 and buffer1 where buffer0 is a source
 * and buffer1 is a destination. When the buffer descriptor is a single
 * pointer type, the buffer0 is the only pointer used and buffer1 is ignored.
 * Non-BD tasks do not use this function.
 */
BDIdx TaskBDAssign( TaskId taskId, void *buffer0, void *buffer1, int size, uint32 bdFlags )
{
	BDIdx				*bdHead;
	BDIdx				*bdTail;
	BDIdx				currentBDHead;
	TaskBD1_t			*bdTab1;
	TaskBD2_t			*bdTab2;

	if( TaskBDIdxTable[taskId].numBD <= 0 ) {
		/*
		 * Non-buffer descriptor task
		 */
		return TASK_ERR_NO_ERR;
	}
	
	if( TaskBDIdxTable[taskId].currBDInUse == TaskBDIdxTable[taskId].numBD) {
		/*
		 * The buffer ring is full.
		 */
		return TASK_ERR_BD_RING_FULL;
	}
	
	if( TaskBDIdxTable[taskId].apiConfig & API_CONFIG_BD_FLAG ) {
		if( (uint32)size & (uint32)(~SDMA_DRD_MASK_LENGTH) ) {
			return TASK_ERR_SIZE_TOO_LARGE;
		}
	} else {
		if( (uint32)size & (uint32)(0xffffffff<<SDMA_BD_BIT_READY) ) {
			return TASK_ERR_SIZE_TOO_LARGE;
		}
	}

	bdHead	= &BDHead[taskId];
	bdTail	= &BDTail[taskId];
	
	/*
	 * Increase Buffer Descriptor in use variable.
	 */
	 
	(TaskBDIdxTable[taskId].currBDInUse)++; 
		
	/*
	 * Determine which type of buffer descriptor to operate on
	 */
	
	switch( TaskBDIdxTable[taskId].numPtr ) {
		
		
		/*
		 * Buffer descriptor type with one pointer
		 */
		 
		case 1:
			bdTab1	= (TaskBD1_t *)TaskBDIdxTable[taskId].BDTablePtr;
			/*
	 		 * Check if the BD ring is full.
	 		 */
			if( bdTab1[*bdHead].DataPtr[0] != (uint32)NULL ) {
				return TASK_ERR_BD_RING_FULL;
			}
			
			bdTab1[*bdHead].DataPtr[0] = (uint32)buffer0;
			
			/*
	 		 * Clear status bits, set length
	 		 */
			if( TaskBDIdxTable[taskId].apiConfig & API_CONFIG_BD_FLAG ) {
				bdTab1[*bdHead].Status = ( ((uint32)SDMA_DRD_MASK_FLAGS  & bdFlags)
							 | ((uint32)SDMA_DRD_MASK_LENGTH & (uint32)size)
							 | ((uint32)SDMA_BD_MASK_READY));
			} else {
				bdTab1[*bdHead].Status = ( ((uint32)SDMA_BD_MASK_SIGN    & (uint32)size)
							 | ((uint32)SDMA_BD_MASK_READY));
			}
			
			break;
					
		/*
		 * Buffer descriptor type with two pointers.
		 */
		 
		case 2:
			bdTab2	= (TaskBD2_t *)TaskBDIdxTable[taskId].BDTablePtr;
			/*
	 		 * Check if the BD ring is full.
	 		 */
			if( bdTab2[*bdHead].DataPtr[0] != (uint32)NULL ) {
				return TASK_ERR_BD_RING_FULL;
			}
			
			bdTab2[*bdHead].DataPtr[0] = (uint32)buffer0;
			bdTab2[*bdHead].DataPtr[1] = (uint32)buffer1;
			
			/*
	 		 * Clear status bits, set length
	 		 */
			if( TaskBDIdxTable[taskId].apiConfig & API_CONFIG_BD_FLAG ) {
				bdTab2[*bdHead].Status = ( ((uint32)SDMA_DRD_MASK_FLAGS  & bdFlags)
							 | ((uint32)SDMA_DRD_MASK_LENGTH & (uint32)size)
							 | ((uint32)SDMA_BD_MASK_READY));
			} else {
				bdTab2[*bdHead].Status = ( ((uint32)SDMA_BD_MASK_SIGN    & (uint32)size)
							 | ((uint32)SDMA_BD_MASK_READY));
			}			
			break;
	} /* End of Switch statement */


	/*
	 * Return the current BD index and increment.
	 */
	currentBDHead = *bdHead;
	*bdHead = (BDIdx)((*bdHead + 1) % (BDIdx)TaskBDIdxTable[taskId].numBD);
	return currentBDHead;
}

/*!
 * \brief	Release last buffer in buffer descriptor ring.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 *
 * \returns Buffer descriptor index of next buffer index that will be released
 *			by another call of this function.
 *			Non-buffer descriptor tasks will return TASK_ERR_NO_ERR.
 *			TASK_ERR_INVALID_ARG is returned if the ring is already empty.
 *
 * This function allows the system to reallocate the memory used by
 * the buffer. It also cleans up the structure in the BD ring by
 * removing the tail buffer in the ring. The buffer descriptor tasks
 * are designed around this. Non-BD tasks do not use
 * this function.
 */
BDIdx TaskBDRelease( TaskId taskId )
{
	BDIdx				*bdTail;
	BDIdx				*bdHead;
	TaskBD1_t			*bdTab1;
	TaskBD2_t			*bdTab2;

	if( TaskBDIdxTable[taskId].numBD == 0 ) {
		/*
		 * Non-buffer descriptor task
		 */
		return TASK_ERR_NO_ERR;
	}


	bdTail	= &BDTail[taskId];
	bdHead	= &BDHead[taskId];
	
	if ( TaskBDIdxTable[taskId].currBDInUse == 0 ) {
		/*
		 * Buffer Descriptor ring is empty, Can't Release!
		 */
		 return TASK_ERR_BD_RING_EMPTY;
	} 
 	

 	/* 
	 * Do different things based on buffer descriptor type.
	 */
	 
	
	switch (TaskBDIdxTable[taskId].numPtr)
	{
		case 1:
			bdTab1	= (TaskBD1_t *)TaskBDIdxTable[taskId].BDTablePtr;
			bdTab1[*bdTail].Status     &= (uint32)(~SDMA_BD_MASK_READY);
			bdTab1[*bdTail].DataPtr[0]  = (uint32)NULL;
			break;
		
		case 2:
			bdTab2	= (TaskBD2_t *)TaskBDIdxTable[taskId].BDTablePtr;
			bdTab2[*bdTail].Status     &= (uint32)(~SDMA_BD_MASK_READY);
			bdTab2[*bdTail].DataPtr[0]  = (uint32)NULL;
			bdTab2[*bdTail].DataPtr[1]  = (uint32)NULL;
			break;
	}
	
	
	*bdTail = (BDIdx)((*bdTail + 1) % (BDIdx)TaskBDIdxTable[taskId].numBD);

	/*
	 * Decrement the in use buffer descriptors
	 */
	 
	(TaskBDIdxTable[taskId].currBDInUse)--;
	
	return *bdTail;
}

/*!
 * \brief	Return a pointer to a buffer descriptor at index BDIdx
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \param	bd		Buffer descriptor handle returned by
 *					TaskBDAssign() or TaskTransferFinish().
 * \returns	Pointer to the requested buffer descriptor or NULL on error.
 *
 * The returned pointer should be cast to the appropriate buffer
 * descriptor type, TaskBD1_t or TaskBD2_t.
 */
TaskBD_t *TaskGetBD( TaskId taskId, BDIdx bd )
{
	TaskBD1_t *bdTab1;
	TaskBD2_t *bdTab2;

	if( (taskId < 0) || (taskId >= MAX_TASKS) ) {
		return NULL;
	}
	if( (bd < 0) || (bd >= TaskBDIdxTable[taskId].numBD) ) {
		return NULL;
	}

	switch( TaskBDIdxTable[taskId].numPtr ) {
		case 1:
			bdTab1 = (TaskBD1_t *)TaskBDIdxTable[taskId].BDTablePtr;
			return (TaskBD_t *)&bdTab1[bd];
			break;
		case 2:
			bdTab2 = (TaskBD2_t *)TaskBDIdxTable[taskId].BDTablePtr;
			return (TaskBD_t *)&bdTab2[bd];
			break;
	}

	return NULL;
}

/*!
 * \brief	Return a pointer to the first buffer descriptor in the ring.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \returns	Pointer to the array of buffer descriptors making up the
 *			ring or NULL on error.
 *
 * A device driver author may choose to use this in lieu of
 * TaskBDAssign()/TaskBDRelease() to get direct access to the
 * BD ring with the warning that the underlying data structure may change.
 * Use at one's own discretion.
 */
TaskBD_t *TaskGetBDRing( TaskId taskId )
{
	if( (taskId < 0) || (taskId >= MAX_TASKS) ) {
		return NULL;
	}

	return TaskBDIdxTable[taskId].BDTablePtr;
}

/*!
 * \brief	Clear the interrupt for a given BestComm task.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \returns	0 on success or negative on failure
 * \returns	TASK_ERR_NO_ERR (which is not really an error) for success
 *			or TASK_ERR_INVALID_ARG for an invalid taskId.
 */
int TaskIntClear( TaskId taskId )
{
	if(    ((taskId >= 0)
		&& (taskId <  MAX_TASKS))
		|| (taskId == DEBUG_INTR_ID)
		|| (taskId == TEA_INTR_ID)
	  ) {

		SDMA_CLEAR_IEVENT( SDMA_INT_PEND, taskId );
		return TASK_ERR_NO_ERR;	/* success */
	} else {
		return TASK_ERR_INVALID_ARG;
	}
}

/*!
 * \brief	Get the interrupt status for a given task.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \returns	TASK_ERR_NO_INTR (which is not really an error) for no interrupt
 *			pending, taskId for a regular interrupt, DEBUG_INTR_ID for
 *			a debug interrupt and TEA_INTR_ID for a TEA interrupt.
 *			\b NOTE: \b TaskIntStatus may return 0, but this means that that
 *          taskId 0 is interrupt pending. Check the function description
 *			for TaskIntPending.
 */
TaskId TaskIntStatus( TaskId taskId )
{
	uint32 pending;

	if(  (  (taskId >= 0)
		&& (taskId <  MAX_TASKS) )
		|| (taskId == DEBUG_INTR_ID)
		|| (taskId == TEA_INTR_ID)
	  ) {

		pending = SDMA_INT_PENDING( SDMA_INT_PEND, SDMA_INT_MASK );

		if( SDMA_INT_TEST( pending, taskId ) ) {
			return taskId;
		} else if( SDMA_INT_TEST( pending, DEBUG_INTR_ID ) ) {
			return DEBUG_INTR_ID;
		} else if( SDMA_INT_TEST( pending, TEA_INTR_ID ) ) {
			return TEA_INTR_ID;
		} else {
			return TASK_ERR_NO_INTR;
		}

	} else {
		return TASK_ERR_INVALID_ARG;
	}
}

/*!
 * \brief	Get the interrupt pending status for a given task.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \returns	0 if task does not have a pending interrupt. 1 if the task
 *			has an interrupt pending.
 *
 *
 */
int TaskIntPending( TaskId taskId )
{
	uint32 pending;


	pending = SDMA_INT_PENDING( SDMA_INT_PEND, SDMA_INT_MASK );
	if( SDMA_INT_TEST( pending, taskId ) ) {
		return 1;
	} else {
		return 0;
	}
	
}

/*!
 * \brief	Returns the task ID of an interrupting BestComm task.
 * \returns	TASK_ERR_NO_INTR (which is not really an error) for no interrupt
 *			pending or the taskId of the interrupting task.
 *
 * The user must query TaskIntStatus() to discover if this is a debug
 * or TEA interrupt. This function is designed for use by an operating
 * system interrupt handler.
 */
TaskId TaskIntSource( void )
{
	uint32 pending;
	uint32 mask = 1 << (MAX_TASKS - 1);
	TaskId i;

	pending = SDMA_INT_PENDING( SDMA_INT_PEND, SDMA_INT_MASK );

	if( SDMA_INT_TEST( pending, SDMA_INT_BIT_TEA ) ) {
		return (TaskId)SDMA_TEA_SOURCE( SDMA_INT_PEND );
	}

	for( i = (MAX_TASKS - 1); i >= 0; --i, mask >>= 1 ) {
		if( pending & mask ) {
			return i;
		}
	}

	return TASK_ERR_NO_INTR;
}

/*!
 * \brief	Return BestComm debug information.
 * \param	taskId	Task handle passed back from a successful TaskSetup()
 * \param	paramSet	TBD
 * \returns	TBD
 *
 * The implementation of this function is yet to be determined.
 */
int TaskDebug( TaskId taskId, TaskDebugParamSet_t *paramSet )
{
	if( (taskId < 0) || (taskId >= MAX_TASKS) ) {
		return TASK_ERR_INVALID_ARG;
	}
	if( paramSet == NULL ) {
		return TASK_ERR_INVALID_ARG;
	}

	return TASK_ERR_NO_ERR;
}

